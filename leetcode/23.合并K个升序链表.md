# 23. 合并 K 个升序链表

## 题目描述

给定一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序链表中，返回合并后的链表。

### 示例 1

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到：
1->1->2->3->4->4->5->6
```

### 示例 2

```
输入：lists = []
输出：[]
```

### 示例 3

```
输入：lists = [[]]
输出：[]
```

### 提示

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按升序排列
- `lists[i].length` 的总和不超过 `10^4`

---

## 解题思路

### 核心思想

合并K个有序链表，可以使用以下方法：

1. **优先队列（堆）**：维护一个最小堆，每次取出最小的节点 ⭐
2. **分治合并**：两两合并链表，类似归并排序
3. **顺序合并**：依次合并每个链表（效率较低）

### 算法步骤（优先队列法）

1. 创建虚拟头节点
2. 将所有链表的头节点加入优先队列
3. 每次取出最小节点，加入结果链表
4. 如果该节点还有下一个节点，将其加入优先队列
5. 重复步骤3-4直到队列为空

---

## 方法一：优先队列（堆）（推荐）⭐

### 思路

使用最小堆维护所有链表的当前最小节点，每次取出堆顶节点加入结果链表。

### 代码实现

```python
import heapq
from typing import List, Optional

# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        使用优先队列合并K个有序链表
        
        时间复杂度: O(N log K)，其中N是所有链表中的节点总数，K是链表个数
        空间复杂度: O(K)，优先队列中最多有K个节点
        """
        # 创建虚拟头节点
        dummy = ListNode(0)
        current = dummy
        
        # 创建优先队列，存储每个链表的头节点
        # 使用(节点值, 链表索引, 节点)作为元组，确保相同值的节点可以正确比较
        pq = []
        for i, node in enumerate(lists):
            if node:
                heapq.heappush(pq, (node.val, i, node))
        
        # 当优先队列不为空时，不断取出最小节点
        while pq:
            # 取出当前最小节点
            val, i, node = heapq.heappop(pq)
            
            # 将节点添加到结果链表中
            current.next = node
            current = current.next
            
            # 如果该链表还有下一个节点，将其加入优先队列
            if node.next:
                heapq.heappush(pq, (node.next.val, i, node.next))
        
        return dummy.next
```

### 执行过程示例

以 `lists = [[1,4,5],[1,3,4],[2,6]]` 为例：

```
初始状态：
  优先队列: [(1,0,node1), (1,1,node2), (2,2,node3)]
  
第1次循环：
  取出: (1,0,node1)
  结果: 1
  加入: (4,0,node1.next)
  队列: [(1,1,node2), (2,2,node3), (4,0,node1.next)]
  
第2次循环：
  取出: (1,1,node2)
  结果: 1->1
  加入: (3,1,node2.next)
  队列: [(2,2,node3), (3,1,node2.next), (4,0,node1.next)]
  
... 继续直到队列为空
```

### 复杂度分析

- **时间复杂度**：O(N log K)，其中N是所有节点总数，K是链表个数
  - 每个节点入队出队一次：O(N)
  - 堆操作：O(log K)
- **空间复杂度**：O(K)，优先队列最多存储K个节点

---

## 方法二：分治合并

### 思路

类似归并排序，将K个链表两两合并，直到只剩一个链表。

### 代码实现

```python
from typing import List, Optional

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        分治合并：两两合并链表
        
        时间复杂度: O(N log K)
        空间复杂度: O(1)（不考虑递归栈）
        """
        if not lists:
            return None
        
        return self.merge(lists, 0, len(lists) - 1)
    
    def merge(self, lists, left, right):
        """分治合并"""
        if left == right:
            return lists[left]
        
        mid = (left + right) // 2
        l1 = self.merge(lists, left, mid)
        l2 = self.merge(lists, mid + 1, right)
        
        return self.mergeTwoLists(l1, l2)
    
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        """合并两个有序链表"""
        dummy = ListNode(0)
        current = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next
        
        current.next = l1 if l1 else l2
        return dummy.next
```

### 复杂度分析

- **时间复杂度**：O(N log K)
  - 合并两个链表：O(N)
  - 分治层数：O(log K)
- **空间复杂度**：O(log K)，递归栈的深度

---

## 方法三：顺序合并

### 思路

依次合并每个链表到结果链表中。

### 代码实现

```python
from typing import List, Optional

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        顺序合并：依次合并每个链表
        
        时间复杂度: O(K × N)，其中K是链表个数，N是平均每个链表的长度
        空间复杂度: O(1)
        """
        if not lists:
            return None
        
        result = lists[0]
        for i in range(1, len(lists)):
            result = self.mergeTwoLists(result, lists[i])
        
        return result
    
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        """合并两个有序链表"""
        dummy = ListNode(0)
        current = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next
        
        current.next = l1 if l1 else l2
        return dummy.next
```

### 复杂度分析

- **时间复杂度**：O(K × N)，效率较低
- **空间复杂度**：O(1)

---

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 | 推荐度 |
|------|-----------|-----------|------|------|--------|
| **优先队列** | O(N log K) | O(K) | 最优时间复杂度，代码简洁 | 需要额外空间 | ⭐⭐⭐⭐⭐ |
| **分治合并** | O(N log K) | O(log K) | 时间复杂度最优，空间复杂度更优 | 代码稍复杂 | ⭐⭐⭐⭐ |
| **顺序合并** | O(K × N) | O(1) | 代码简单 | 时间复杂度高 | ⭐⭐ |

### 推荐方法

**优先队列法**是最优解，时间复杂度O(N log K)，代码简洁易懂。

---

## 关键点

1. **为什么使用元组 `(val, i, node)`？**
   - Python的heapq在比较元组时，如果第一个元素相同，会比较第二个元素
   - 使用索引`i`确保相同值的节点可以正确比较（避免比较ListNode对象）

2. **虚拟头节点的作用**
   - 简化边界处理
   - 统一处理逻辑

3. **优先队列 vs 分治合并**
   - 优先队列：代码更简洁，但需要额外空间
   - 分治合并：空间复杂度更优，但代码稍复杂

---

## 测试用例

```python
def create_linked_list(values: List[int]) -> Optional[ListNode]:
    """创建链表"""
    if not values:
        return None
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def linked_list_to_list(head: Optional[ListNode]) -> List[int]:
    """链表转列表"""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

def test_merge_k_lists():
    solution = Solution()
    
    # 测试用例1
    list1 = create_linked_list([1, 4, 5])
    list2 = create_linked_list([1, 3, 4])
    list3 = create_linked_list([2, 6])
    result = solution.mergeKLists([list1, list2, list3])
    assert linked_list_to_list(result) == [1, 1, 2, 3, 4, 4, 5, 6]
    
    # 测试用例2：空数组
    assert solution.mergeKLists([]) is None
    
    # 测试用例3：包含空链表
    list4 = create_linked_list([1, 2, 3])
    assert linked_list_to_list(solution.mergeKLists([None, list4])) == [1, 2, 3]
    
    print("所有测试用例通过！")

test_merge_k_lists()
```

---

## 相关题目

- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- [LCR 078. 合并K个升序链表](https://leetcode.cn/problems/vvXgSW/description/)（相同题目）
- [1669. 合并两个链表](https://leetcode.cn/problems/merge-in-between-linked-lists/)

---

## 总结

这是一道经典的**链表合并问题**，核心是：

1. **识别问题类型**：多路归并问题
2. **选择数据结构**：优先队列（堆）是最优选择
3. **处理边界情况**：空数组、空链表
4. **注意细节**：使用元组避免ListNode比较错误

**关键技巧**：
- 使用虚拟头节点简化代码
- 优先队列中使用 `(val, i, node)` 元组
- 分治合并适合空间受限的场景
