# 695. 岛屿的最大面积

<!-- 元数据标签（便于AI检索和分类） -->
**标签**：`DFS` `BFS` `图遍历` `矩阵`  
**分类**：`图` `深度优先搜索` `广度优先搜索`  
**难度**：⭐⭐ 中等  
**频率**：🔥🔥🔥 高频

---

## 题目描述

给你一个大小为 `m x n` 的二进制矩阵 `grid`。

**岛屿**是由一些相邻的 `1`（代表土地）构成的组合，这里的「相邻」要求两个 `1` 必须在**水平或者竖直的四个方向上**相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

**岛屿的面积**是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中**最大的岛屿面积**。如果没有岛屿，则返回面积为 `0`。

### 示例 1

```
输入：grid = [
  [0,0,1,0,0,0,0,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,1,1,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,0,1,1,0,0,1,0,1,0,0],
  [0,1,0,0,1,1,0,0,1,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,0,0,0,0,0,0,1,1,0,0,0,0]
]
输出：6
解释：答案不应该是 11，因为岛屿只能包含水平或垂直这四个方向上的 1。
```

### 示例 2

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

### 提示

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `grid[i][j]` 为 `0` 或 `1`

---

## 📋 面试要点速查（知识卡片）

### 核心思路
**一句话总结**：使用DFS或BFS遍历每个岛屿，计算每个岛屿的面积，返回最大面积。

**关键词**：`DFS` `BFS` `连通分量` `面积计算`

### 复杂度速记
- **时间复杂度**：O(m × n) - 每个单元格最多访问一次
- **空间复杂度**：O(m × n) - 递归栈或队列的空间

### 记忆口诀
"遍历网格找岛屿，DFS/BFS算面积，记录最大返回值"

### 代码模板（可直接套用）

```python
def maxAreaOfIsland(grid):
    # 1. 边界检查
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    max_area = 0
    
    # 2. 遍历每个单元格
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                # 3. 计算当前岛屿面积
                area = dfs(i, j)  # 或 bfs(i, j)
                max_area = max(max_area, area)
    
    return max_area
```

---

## 解题思路

### 核心思想

这是一个经典的**连通性问题**，需要找到所有连通分量（岛屿），并计算每个连通分量的面积，返回最大值。

**关键点：**
- 使用DFS或BFS遍历每个岛屿的所有单元格
- 在遍历过程中计算岛屿面积（统计1的个数）
- 遍历过的单元格标记为0，避免重复访问
- 记录并返回所有岛屿中的最大面积

### 算法步骤

1. 遍历整个网格的每个单元格
2. 当遇到 `1`（未访问的陆地）时：
   - 使用DFS或BFS遍历整个岛屿
   - 在遍历过程中计算岛屿面积
   - 更新最大面积
3. 返回最大面积

### 为什么选择这个方法？

- **优势**：DFS/BFS是解决连通性问题的标准方法，思路清晰，实现简单
- **适用场景**：所有需要遍历连通分量的场景
- **替代方案**：并查集也可以解决，但实现相对复杂

---

## 代码实现

### 方法一：DFS（深度优先搜索）⭐

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        """
        DFS方法：递归遍历每个岛屿
        
        时间复杂度: O(m × n)
        空间复杂度: O(m × n) - 递归栈
        """
        if not grid or not grid[0]:
            return 0
        
        res = 0
        m, n = len(grid), len(grid[0])
        
        def dfs(i, j):
            # 边界检查和有效性检查
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
                return 0
            
            # 标记为已访问
            grid[i][j] = 0
            
            area = 1

            # 递归访问四个方向
            area += dfs(i + 1, j)  # 下
            area += dfs(i - 1, j)  # 上
            area += dfs(i, j + 1)  # 右
            area += dfs(i, j - 1)  # 左

            return area
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(dfs(i, j), res)
        
        return res
```

**代码要点**：
- ✅ 使用递归实现DFS，代码简洁
- ✅ 在DFS中直接计算面积，返回当前岛屿的面积
- ✅ 遍历过的单元格标记为0，避免重复访问
- ✅ 使用`max()`函数实时更新最大面积

### 方法二：BFS（广度优先搜索）

```python
from collections import deque
from typing import List

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        """
        BFS方法：使用队列遍历每个岛屿
        
        时间复杂度: O(m × n)
        空间复杂度: O(m × n) - 队列空间
        """
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        max_area = 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上、下、左、右
        
        def bfs(start_i, start_j):
            queue = deque([(start_i, start_j)])
            grid[start_i][start_j] = 0  # 标记为已访问
            area = 1
            
            while queue:
                i, j = queue.popleft()
                
                # 遍历四个方向
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    
                    # 检查边界和有效性
                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:
                        grid[ni][nj] = 0  # 标记为已访问
                        area += 1
                        queue.append((ni, nj))
            
            return area
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    max_area = max(max_area, bfs(i, j))
        
        return max_area
```

### 版本对比分析

| 对比项 | DFS | BFS | 说明 |
|--------|-----|-----|------|
| **时间复杂度** | O(m × n) | O(m × n) | 相同 |
| **空间复杂度** | O(m × n) | O(m × n) | 递归栈 vs 队列 |
| **代码复杂度** | 简单 | 中等 | DFS更简洁 |
| **适用场景** | 深度优先遍历 | 广度优先遍历 | 本题两者均可 |

### 执行过程示例

以示例1为例：

```
初始网格：
[0,0,1,0,0,0,0,1,0,0,0,0,0]
[0,0,0,0,0,0,0,1,1,1,0,0,0]
[0,1,1,0,1,0,0,0,0,0,0,0,0]
[0,1,0,0,1,1,0,0,1,0,1,0,0]
[0,1,0,0,1,1,0,0,1,1,1,0,0]
[0,0,0,0,0,0,0,0,0,0,1,0,0]
[0,0,0,0,0,0,0,1,1,1,0,0,0]
[0,0,0,0,0,0,0,1,1,0,0,0,0]

遍历过程：
1. (0,2) -> 面积=1
2. (0,7) -> 面积=1
3. (2,1) -> 面积=2
4. (2,4) -> 面积=1
5. (3,1) -> 面积=4
6. (3,8) -> 面积=1
7. (3,10) -> 面积=1
8. (5,10) -> 面积=1
9. (6,7) -> 面积=6 (最大)
10. (7,7) -> 面积=4

最终返回：6
```

---

## ⚠️ 常见陷阱（面试易错点）

1. **陷阱1：忘记标记已访问的单元格**
   - ❌ **错误做法**：不标记已访问，导致重复计算
   ```python
   def dfs(i, j):
       if grid[i][j] == 0:
           return 0
       # 忘记标记 grid[i][j] = 0
       return 1 + dfs(i+1, j) + ...
   ```
   - ✅ **正确做法**：访问后立即标记为0
   ```python
   def dfs(i, j):
       if grid[i][j] == 0:
           return 0
       grid[i][j] = 0  # 标记为已访问
       return 1 + dfs(i+1, j) + ...
   ```
   - 💡 **原因分析**：不标记会导致无限递归或重复计算

2. **陷阱2：混淆对角线相邻**
   - ❌ **错误做法**：认为对角线也算相邻
   ```python
   # 错误：包含对角线方向
   directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
   ```
   - ✅ **正确做法**：只考虑上下左右四个方向
   ```python
   # 正确：只有四个方向
   directions = [(-1,0), (1,0), (0,-1), (0,1)]
   ```
   - 💡 **原因分析**：题目明确要求"水平或竖直的四个方向上相邻"

3. **陷阱3：边界检查不完整**
   - ❌ **错误做法**：只检查一个边界
   ```python
   if i >= m or j >= n or grid[i][j] == 0:
       return 0
   ```
   - ✅ **正确做法**：检查所有边界
   ```python
   if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
       return 0
   ```
   - 💡 **原因分析**：数组索引可能为负数，需要检查下界

4. **边界情况**
   - **空网格**：返回0
   - **全为0**：返回0
   - **全为1**：返回 m × n

---

## 优化点说明

1. **优化1：使用方向数组**
   - **效果**：代码更简洁，易于扩展
   - **实现**：
   ```python
   directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
   for di, dj in directions:
       ni, nj = i + di, j + dj
   ```

2. **优化2：原地修改数组**
   - **效果**：节省空间，不需要额外的visited数组
   - **实现**：将访问过的单元格标记为0

---

## 复杂度分析

### 时间复杂度

- **最坏情况**：O(m × n) - 需要遍历所有单元格
- **最好情况**：O(m × n) - 即使全为0也要遍历一遍
- **平均情况**：O(m × n) - 每个单元格最多访问一次

### 空间复杂度

- **额外空间**：O(1) - 只使用常数额外变量
- **递归栈**：O(m × n) - DFS最坏情况下递归深度为m×n
- **队列空间**：O(m × n) - BFS最坏情况下队列大小为m×n

### 复杂度对比表

| 方法 | 时间复杂度 | 空间复杂度 | 备注 |
|------|-----------|-----------|------|
| DFS | O(m × n) | O(m × n) | 推荐，代码简洁 |
| BFS | O(m × n) | O(m × n) | 备选，避免栈溢出 |

---

## 关键点

1. **为什么使用DFS/BFS？**
   - 这是连通性问题的标准解法
   - DFS/BFS可以遍历整个连通分量
   - **面试要点**：需要理解DFS和BFS的区别和适用场景

2. **如何计算岛屿面积？**
   - 在遍历过程中统计访问到的1的个数
   - DFS：递归返回面积累加
   - BFS：在队列遍历过程中计数
   - **面试要点**：理解递归和迭代两种实现方式

3. **如何避免重复访问？**
   - 访问后立即标记为0（或使用visited数组）
   - 在DFS/BFS开始前就标记起点
   - **面试要点**：理解为什么需要标记，以及标记的时机

4. **为什么只能四个方向？**
   - 题目明确要求"水平或竖直的四个方向上相邻"
   - 对角线不算相邻
   - **面试要点**：注意审题，理解题目要求

---

## 💬 面试问题（模拟面试场景）

### 基础问题

1. **Q: 这道题的核心思路是什么？**
   - A: 使用DFS或BFS遍历每个岛屿，在遍历过程中计算每个岛屿的面积，记录并返回最大面积。

2. **Q: 为什么选择DFS而不是BFS？**
   - A: 对于这个问题，DFS和BFS都可以，但DFS代码更简洁。如果岛屿很大，DFS可能栈溢出，此时BFS更安全。

3. **Q: 时间复杂度是如何推导的？**
   - A: 每个单元格最多被访问一次（访问后标记为0），所以时间复杂度是O(m × n)。

### 进阶问题

1. **Q: 如果数据规模增大10倍，你会如何优化？**
   - A: 
     - 使用迭代DFS避免栈溢出
     - 使用BFS避免深度递归
     - 考虑并行处理（如果允许修改原数组）
     - 使用并查集（如果不需要修改原数组）

2. **Q: 这道题有哪些变种？**
   - A: 
     - 200.岛屿数量：统计岛屿个数
     - 463.岛屿的周长：计算岛屿周长
     - 827.最大人工岛：可以改变一个0为1
     - 130.被围绕的区域：标记被围绕的区域

3. **Q: 在实际项目中，你会如何应用这个算法？**
   - A: 
     - 图像处理：连通区域分析
     - 游戏开发：地图区域划分
     - 数据分析：聚类分析
     - 网络分析：连通分量分析

### 代码实现问题

1. **Q: 这段代码的时间复杂度是多少？**
   - A: O(m × n)，每个单元格最多访问一次。

2. **Q: 如何优化这段代码？**
   - A: 
     - 使用方向数组简化代码
     - 使用迭代DFS避免栈溢出
     - 如果允许，可以使用并查集

---

## 其他方法（可选）

### 并查集（Union-Find）

虽然可以使用并查集，但对于这个问题，DFS/BFS更直观简单。

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            self.parent[px] = py
            self.size[py] += self.size[px]

# 使用并查集解决（代码较复杂，不推荐）
```

- **时间复杂度**：O(m × n × α(m×n))，α是阿克曼函数的反函数
- **空间复杂度**：O(m × n)
- **为什么不推荐**：实现复杂，对于这个问题DFS/BFS更简单直接

---

## 🔗 相似题目对比

| 题目 | 相似点 | 不同点 | 难度 |
|------|--------|--------|------|
| [200.岛屿数量](200.岛屿数量.md) | 都是连通性问题，使用DFS/BFS | 统计个数 vs 计算最大面积 | ⭐⭐ |
| [463.岛屿的周长](https://leetcode.cn/problems/island-perimeter/) | 都是岛屿问题 | 计算周长 vs 计算面积 | ⭐ |
| [827.最大人工岛](https://leetcode.cn/problems/making-a-large-island/) | 都是岛屿面积问题 | 可以改变一个0为1 | ⭐⭐⭐ |

**对比说明**：
- **200.岛屿数量**：只需要统计岛屿个数，不需要计算面积
- **463.岛屿的周长**：需要计算岛屿的周长，思路类似但计算方式不同
- **827.最大人工岛**：可以改变一个0为1，需要枚举所有可能

---

## 相关题目

### 同类型题目
- [200.岛屿数量](200.岛屿数量.md) - 统计岛屿个数
- [463.岛屿的周长](https://leetcode.cn/problems/island-perimeter/) - 计算岛屿周长
- [130.被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) - 标记被围绕的区域

### 进阶题目
- [827.最大人工岛](https://leetcode.cn/problems/making-a-large-island/) - 可以改变一个0为1，求最大岛屿
- [1020.飞地的数量](https://leetcode.cn/problems/number-of-enclaves/) - 统计不与边界相连的陆地数量

### 变种题目
- [1254.统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/) - 统计完全被水包围的岛屿

---

## 总结

这是一道经典的**图遍历**题目，核心是：

1. **识别问题类型**：连通性问题，需要遍历连通分量
2. **选择算法**：DFS或BFS都可以，DFS代码更简洁
3. **计算面积**：在遍历过程中统计访问到的1的个数
4. **避免重复**：访问后立即标记，避免重复计算

**关键技巧**：
- ✅ 使用DFS/BFS遍历连通分量
- ✅ 在遍历过程中计算面积
- ✅ 访问后立即标记，避免重复访问
- ✅ 只考虑上下左右四个方向（不包括对角线）

**面试建议**：
- 🎯 先说明思路，再写代码
- 🎯 注意边界检查的完整性
- 🎯 理解DFS和BFS的区别和适用场景
- 🎯 能够说出时间复杂度和空间复杂度的推导过程
