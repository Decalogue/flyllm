# 2. 两数相加

## 题目描述

给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

### 示例 1

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807
```

### 示例 2

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

### 示例 3

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

### 提示

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

---

## 解题思路

### 核心思想

模拟加法运算过程，从低位到高位逐位相加，处理进位。

**关键点：**
- 数字按**逆序**存储（个位在前）
- 需要处理**进位**
- 两个链表长度可能不同
- 最后可能还有进位需要添加新节点

### 算法步骤（优化版）

1. 创建虚拟头节点，简化边界处理
2. 使用统一的循环条件 `while l1 or l2 or carry != 0`，处理链表长度不同和最后进位的情况
3. 每次循环：如果链表还有节点，累加其值到 `carry`
4. 计算当前位值：`carry % 10`，更新进位：`carry //= 10`
5. 创建新节点并移动指针，继续下一次循环

---

## 代码实现

```python
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 初版
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: Optional[ListNode]
        :type l2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        res = ListNode(0)
        r = res
        carry = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            s = carry + x + y
            carry = s // 10
            r.next = ListNode(s % 10)
            r = r.next
            if l1 != None:
                l1 = l1.next 
            if l2 != None:
                l2 = l2.next
            if carry > 0:
                r.next = ListNode(1)
        return res.next

# 优化版
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        res = ListNode()
        r = res
        carry = 0
        while l1 or l2 or carry != 0:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            r.next = ListNode(carry % 10)
            carry //= 10
            r = r.next
        return res.next
```

### 版本对比分析

| 对比项 | 初版 | 优化版 | 说明 |
|--------|------|--------|------|
| **虚拟头节点** | `ListNode(0)` | `ListNode()` | 优化版使用默认参数，更简洁 |
| **循环条件** | `while l1 or l2` | `while l1 or l2 or carry != 0` | 优化版在循环条件中处理最后进位，更优雅 |
| **值获取方式** | 三元表达式 `x = l1.val if l1 else 0` | 条件判断 `if l1: carry += l1.val` | 优化版直接累加到carry，减少变量 |
| **计算方式** | 先计算 `s = carry + x + y`，再分别处理 | 直接 `carry += l1.val`，然后 `carry % 10` | 优化版更直接，减少中间变量 |
| **进位处理** | 循环内 `if carry > 0: r.next = ListNode(1)` | 循环条件 `or carry != 0` | 优化版统一处理，逻辑更清晰 |
| **链表移动** | `if l1 != None: l1 = l1.next` | `if l1: l1 = l1.next` | 优化版使用Python惯用法，更简洁 |
| **代码行数** | 16行 | 12行 | 优化版更简洁 |


### 执行过程示例（优化版）

以 `l1 = [2,4,3]`, `l2 = [5,6,4]` 为例：

```
初始：res = 0 -> None, r = res, carry = 0

第1次循环（个位）：
  l1存在：carry += 2  → carry = 2
  l2存在：carry += 5  → carry = 7
  r.next = ListNode(7)  → res = 0 -> 7 -> None
  carry //= 10  → carry = 0
  r = r.next

第2次循环（十位）：
  l1存在：carry += 4  → carry = 4
  l2存在：carry += 6  → carry = 10
  r.next = ListNode(0)  → res = 0 -> 7 -> 0 -> None
  carry //= 10  → carry = 1
  r = r.next

第3次循环（百位）：
  l1存在：carry += 3  → carry = 4
  l2存在：carry += 4  → carry = 8
  r.next = ListNode(8)  → res = 0 -> 7 -> 0 -> 8 -> None
  carry //= 10  → carry = 0
  r = r.next

循环结束（l1=None, l2=None, carry=0）
返回 res.next = 7 -> 0 -> 8
```

---

## 复杂度分析

- **时间复杂度**：O(max(m, n))，需要遍历较长的链表
- **空间复杂度**：O(max(m, n))，结果链表的长度最多为 max(m, n) + 1

---

## 关键点

1. **虚拟头节点的使用**
   - 使用 `res = ListNode()` 作为虚拟头节点（使用默认参数）
   - 简化边界处理，统一处理逻辑
   - 最后返回 `res.next`

2. **统一的循环条件** ⭐
   - 使用 `while l1 or l2 or carry != 0` 统一处理所有情况
   - 链表长度不同：已遍历完的链表在条件判断中自动跳过
   - 最后进位：通过 `carry != 0` 在循环中统一处理，避免遗漏

3. **进位处理**
   - 使用 `carry` 变量记录进位，初始化为0
   - 累加方式：`carry += l1.val`（如果链表存在）
   - 计算当前位：`carry % 10`，更新进位：`carry //= 10`
   - **⚠️ 注意**：必须使用整数除法 `//`，不能使用 `/`，否则在Python 3中会得到浮点数

4. **为什么数字是逆序存储？**
   - 逆序存储使得加法运算更简单，从个位开始逐位相加
   - 如果是正序存储，需要先反转链表或使用栈

---

## 相关题目

- [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)（数字正序存储）
- [67. 二进制求和](https://leetcode.cn/problems/add-binary/)
- [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

---

## 总结

这是一道经典的**链表操作**题目，核心是：

1. **识别问题类型**：模拟加法运算，从低位到高位逐位相加
2. **使用虚拟头节点**：简化边界处理，统一处理逻辑
3. **统一循环条件**：`while l1 or l2 or carry != 0` 处理链表长度不同和最后进位
4. **处理进位**：使用 `carry` 变量累加和记录进位，每次循环更新

**关键技巧**：
- ✅ 使用虚拟头节点简化代码
- ✅ 循环条件包含 `carry != 0`，统一处理最后进位
- ✅ 使用 `//` 和 `%` 运算符计算进位和当前位（注意用 `//` 不是 `/`）
- ✅ 直接累加到 `carry`，减少中间变量
- ✅ 使用 `if l1:` 而不是 `if l1 != None:`（Python惯用法）

**推荐使用优化版**，代码更简洁、逻辑更严谨。
