# 二叉树根节点到叶子节点的所有路径和

## 题目描述

给定一个二叉树的根节点 `root`，该树的节点值都在 **0~9** 之间，每一条从根节点到叶子节点的路径都可以用一个数字表示。

**说明：**
1. 路径定义为从树的根结点开始往下一直到叶子结点所经过的结点
2. 叶子节点是指没有子节点的节点
3. 路径只能从父节点到子节点，不能从子节点到父节点
4. 总节点数目为 n

例如根节点到叶子节点的一条路径是 1→2→3，那么这条路径就用 **123** 来代替。

请找出根节点到叶子节点的所有路径表示的数字之和。

**示例：**  
二叉树有两条路径：  
- 根节点到叶子节点路径 1→2 用数字 **12** 代替  
- 根节点到叶子节点路径 1→3 用数字 **13** 代替  
所以答案为 12 + 13 = **25**。

### 示例 1

```
输入：{1,2,3}
输出：25
```

### 示例 2

```
输入：{1,0}
输出：10
```

### 示例 3

```
输入：{1,2,0,3,4}
输出：257
```

### 数据范围

- 节点数 1 ≤ n ≤ 10^5，保证结果在 32 位整型范围内
- **要求**：空间复杂度 O(n)，时间复杂度 O(n)
- **进阶**：空间复杂度 O(树高)，时间复杂度 O(n)

---

## 解题思路

### 核心思想

用 **DFS（深度优先搜索）** 从根走到叶，在递归过程中维护「当前路径组成的数字」，到达叶子时把该数字加入总和。

**算法步骤：**
1. 从根节点开始 DFS，初始路径数字为 0
2. 每进入一个节点：当前路径数字 = 上一段路径数字 × 10 + 当前节点值
3. 若当前节点是**叶子节点**（无左右子节点），返回当前路径数字
4. 否则递归左右子树，把两边返回值相加后返回

---

## 代码实现

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# @param root TreeNode类
# @return int整型
#
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        """
        DFS：在递归中维护「根到当前节点」形成的数字，到叶子时累加
        
        时间复杂度: O(n)
        空间复杂度: O(树高)，递归栈
        """
        def dfs(node: TreeNode, num: int) -> int:
            if not node:
                return 0
            num = num * 10 + node.val
            if not node.left and not node.right:
                return num
            return dfs(node.left, num) + dfs(node.right, num)

        return dfs(root, 0)
```

### 执行过程示例

以 `{1,2,3}` 为例（1 为根，左子 2，右子 3）：

```
dfs(1, 0):
  num = 0*10+1 = 1
  非叶子，继续
  left  = dfs(2, 1): num=12, 叶子 → 返回 12
  right = dfs(3, 1): num=13, 叶子 → 返回 13
  返回 12 + 13 = 25
```

---

## 复杂度分析

- **时间复杂度**：O(n)，每个节点访问一次
- **空间复杂度**：O(树高)，递归栈深度等于树高，最坏 O(n)（链状），平衡树 O(log n)

---

## 关键点

1. **为什么到叶子才累加？**  
   题目要求「根到叶子」的路径才构成一个数字，只有叶子节点代表一条完整路径的终点。

2. **`num = num * 10 + node.val` 的含义**  
   父路径形成的数是 `num`，当前节点值是个位，所以新数为 `num * 10 + node.val`。例如路径 1→2→3 依次为 1、12、123。

3. **空节点怎么处理？**  
   `if not node: return 0`，这样单子节点时另一侧返回 0，不影响求和。

4. **进阶空间 O(树高)**  
   本题递归写法栈深度就是树高，已满足进阶；若用迭代 + 显式栈，栈中元素数量也是 O(树高)。

---

## 其他方法

### 迭代（BFS/DFS + 显式栈）

可以用栈或队列同时保存 `(节点, 当前路径数字)`，遍历到叶子时累加。思路与递归一致，只是用显式栈/队列代替递归栈，空间仍是 O(树高)。

---

## 相关题目

- [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)（同题）
- [112. 路径总和](https://leetcode.cn/problems/path-sum/)
- [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
