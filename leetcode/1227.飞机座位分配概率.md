# 1227. 飞机座位分配概率

<!-- 元数据标签（便于AI检索和分类） -->
**标签**：`数学` `动态规划` `概率` `中等`  
**分类**：`数学` / `概率论` / `动态规划`  
**难度**：⭐⭐ 中等  
**频率**：🔥 低频

---

## 题目描述

有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。

剩下的乘客将会：
- 如果他们自己的座位还空着，就坐到自己的座位上
- 当他们自己的座位被占用时，随机选择其他座位

第 n 位乘客坐在自己的座位上的概率是多少？

### 示例 1

```
输入: n = 1
输出: 1.00000
解释: 第一个人只会坐在自己的位置上。
```

### 示例 2

```
输入: n = 2
输出: 0.50000
解释: 在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
```

### 提示

- 1 <= n <= 10^5

---

## 📋 面试要点速查（知识卡片）

### 核心思路
**一句话总结**：通过数学分析发现，无论有多少人，第n个人坐到自己座位的概率总是1/2（n≥2时）。

**关键词**：`概率` `数学归纳` `动态规划`

### 复杂度速记
- **时间复杂度**：O(1) - 直接返回结果
- **空间复杂度**：O(1) - 只使用常数空间

### 记忆口诀
"第一个人随机选，第n个人概率总是一半"

---

## 解题思路

### 核心思想

这是一个经典的概率问题。关键在于发现规律：

**数学归纳法分析：**

1. **n = 1**：只有一个人，概率 = 1
2. **n = 2**：
   - 第1个人选座位1（自己的）：概率1/2，第2个人坐座位2，概率=1
   - 第1个人选座位2（第2个人的）：概率1/2，第2个人坐不到座位2，概率=0
   - 总概率 = 1/2 × 1 + 1/2 × 0 = **1/2**

3. **n = 3**：
   - 第1个人选座位1（自己的）：概率1/3，后续所有人都坐自己座位，第3个人概率=1
   - 第1个人选座位3（第3个人的）：概率1/3，第3个人永远坐不到自己座位，概率=0
   - 第1个人选座位2：概率1/3，问题转化为n=2的情况（第2个人类似第1个人）
   - 总概率 = 1/3 × 1 + 1/3 × 0 + 1/3 × f(2) = 1/3 + 1/3 × 1/2 = **1/2**

4. **一般情况 n ≥ 2**：
   - 第1个人选座位1：概率1/n，第n个人概率=1
   - 第1个人选座位n：概率1/n，第n个人概率=0
   - 第1个人选座位i (2≤i≤n-1)：概率(n-2)/n，转化为子问题f(n-i+1)
   - 经过数学归纳可以证明：**f(n) = 1/2 (n ≥ 2)**

**关键洞察：**
- 当第1个人随机选择时，座位1和座位n是对称的
- 第1个人选座位1 → 第n个人坐座位n的概率=1
- 第1个人选座位n → 第n个人坐座位n的概率=0
- 其他情况会递归到子问题，但最终都收敛到1/2

### 算法步骤

1. 如果 n == 1，返回 1.0
2. 否则，返回 0.5（对于所有 n ≥ 2，概率都是 0.5）

### 为什么是这个答案？

- **数学证明**：通过数学归纳法和对称性分析可以严格证明
- **直观理解**：座位1和座位n在概率上是对称的，第1个人选座位1和选座位n的概率各是1/2
- **动态规划验证**：可以用DP验证，但会发现结果总是1/2

---

## 完整代码实现

### 方法1：直接数学公式（最优）⭐

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        # n=1时概率为1，n≥2时概率为0.5
        return 1.0 if n == 1 else 0.5
```

**复杂度分析：**
- 时间复杂度：O(1)
- 空间复杂度：O(1)

### 方法2：动态规划（验证用）

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1.0
        
        # dp[i] 表示i个人时，第i个人坐到自己座位的概率
        dp = [0.0] * (n + 1)
        dp[1] = 1.0
        
        for i in range(2, n + 1):
            # 第1个人选座位1：概率1/i，第i个人坐自己座位概率=1
            # 第1个人选座位i：概率1/i，第i个人坐自己座位概率=0
            # 第1个人选座位j (2<=j<=i-1)：概率(i-2)/i，转化为子问题
            # 但实际上可以简化
            dp[i] = (1.0 + 0.0 + sum(dp[i - j + 1] for j in range(2, i))) / i
        
        return dp[n]
```

**注意**：这个方法会计算出相同的结果（0.5），但复杂度更高，仅用于理解。

### 方法3：递归（理解用）

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1.0
        
        # 第1个人选座位1：概率1/n，第n个人坐自己座位概率=1
        # 第1个人选座位n：概率1/n，第n个人坐自己座位概率=0
        # 第1个人选座位i (2<=i<=n-1)：概率(n-2)/n
        # 当第1个人选座位i时，问题转化为：有n-i+1个座位，第1个人（实际是第i个人）随机选
        
        prob = 1.0 / n  # 第1个人选座位1
        prob += 0.0 / n  # 第1个人选座位n
        
        # 其他情况递归
        for i in range(2, n):
            prob += (1.0 / n) * self.nthPersonGetsNthSeat(n - i + 1)
        
        return prob
```

---

## 算法图解

### 示例：n = 3

```
情况1：第1个人选座位1（概率1/3）
座位: [1] [2] [3]
乘客:  1   2   3  ← 所有人都坐自己座位，第3个人概率=1

情况2：第1个人选座位3（概率1/3）
座位: [3] [2] [1]
乘客:  1   2   3  ← 第3个人坐不到自己座位，概率=0

情况3：第1个人选座位2（概率1/3）
座位: [2] [1] [3]
乘客:  1   ?   3
        ↓
    问题转化为n=2的情况（第2个人类似第1个人）
    第3个人坐自己座位的概率 = f(2) = 0.5

总概率 = (1/3)×1 + (1/3)×0 + (1/3)×0.5 = 0.5
```

### 一般情况：n = k

```
第1个人选择：
├─ 选座位1（概率1/k）→ 第k个人概率=1
├─ 选座位k（概率1/k）→ 第k个人概率=0
└─ 选座位i，2≤i≤k-1（概率(k-2)/k）
   └─ 转化为子问题f(k-i+1)
   
通过数学归纳：f(k) = 0.5 (k≥2)
```

---

## 数学证明

### 递推关系

设 f(n) 表示 n 个人时，第 n 个人坐到自己座位的概率。

当第1个人选择座位时：
- 选座位1：概率 1/n，此时 f(n) = 1
- 选座位n：概率 1/n，此时 f(n) = 0
- 选座位i (2 ≤ i ≤ n-1)：概率 (n-2)/n，此时问题转化为 f(n-i+1)

因此：
```
f(n) = (1/n) × 1 + (1/n) × 0 + (1/n) × Σ f(n-i+1)  (i=2 to n-1)
     = 1/n + (1/n) × Σ f(n-i+1)  (i=2 to n-1)
```

### 数学归纳法证明 f(n) = 1/2 (n ≥ 2)

**基础情况：**
- f(2) = 1/2 ✓

**归纳假设：**
假设对于所有 k < n，都有 f(k) = 1/2

**证明 f(n) = 1/2：**
通过对称性和数学归纳，可以证明 f(n) = 1/2

---

## 常见错误

### ❌ 错误1：复杂计算
```python
# 错误：试图用复杂的状态转移计算
# 实际上结果很简单
```

### ❌ 错误2：忽略边界情况
```python
def nthPersonGetsNthSeat(self, n: int) -> float:
    return 0.5  # 错误：n=1时应该返回1.0
```

### ✅ 正确思路
```python
def nthPersonGetsNthSeat(self, n: int) -> float:
    return 1.0 if n == 1 else 0.5  # 正确：考虑边界
```

---

## 测试用例

```python
def test_solution():
    solution = Solution()
    
    assert solution.nthPersonGetsNthSeat(1) == 1.0
    assert solution.nthPersonGetsNthSeat(2) == 0.5
    assert solution.nthPersonGetsNthSeat(3) == 0.5
    assert solution.nthPersonGetsNthSeat(100) == 0.5
    assert solution.nthPersonGetsNthSeat(100000) == 0.5
    
    print("所有测试用例通过！")
```

---

## 相似题目

- [880. 索引处的解码字符串](https://leetcode.cn/problems/decoded-string-at-index/) - 类似的数学思维
- [789. 逃脱阻碍者](https://leetcode.cn/problems/escape-the-ghosts/) - 概率/博弈问题

---

## 总结

这是一道经典的数学概率题，关键在于：

1. **发现规律**：n≥2时，概率总是1/2
2. **数学证明**：可以通过数学归纳法或对称性分析
3. **代码实现**：极其简单，只需要一行

**记住：**
- n = 1 → 概率 = 1.0
- n ≥ 2 → 概率 = 0.5

**面试技巧：**
- 先给出数学公式解法（最优）
- 如果面试官要求，可以说明DP思路，但结果相同

