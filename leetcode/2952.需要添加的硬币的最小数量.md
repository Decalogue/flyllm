# 2952. 需要添加的硬币的最小数量

<!-- 元数据标签（便于AI检索和分类） -->
**标签**：`贪心算法` `数组` `排序` `中等`  
**分类**：`贪心算法` / `数组`  
**难度**：⭐⭐ 中等  
**频率**：🔥🔥 中频

---

## 题目描述

给你一个下标从 0 开始的整数数组 `coins`，表示可用的硬币的面值，以及一个整数 `target`。

如果存在某个 `coins` 的子序列总和为 `x`，那么整数 `x` 就是一个可取得的金额。

返回需要添加到数组中的任意面值硬币的最小数量，使范围 `[1, target]` 内的每个整数都属于可取得的金额。

**数组的子序列**：是通过删除原始数组的一些（可能不删除）元素而形成的新的非空数组，删除过程不会改变剩余元素的相对位置。

### 示例 1

```
输入: coins = [1,4,10], target = 19
输出: 2
解释: 需要添加面值为 2 和 8 的硬币各一枚，得到硬币数组 [1,2,4,8,10]。
     可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 2。
```

### 示例 2

```
输入: coins = [1,4,10,5,7,19], target = 19
输出: 1
解释: 只需要添加一枚面值为 2 的硬币，得到硬币数组 [1,2,4,5,7,10,19]。
     可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 1。
```

### 示例 3

```
输入: coins = [1,1,1], target = 20
输出: 3
解释: 需要添加面值为 4、8 和 16 的硬币各一枚，得到硬币数组 [1,1,1,4,8,16]。
```

### 提示

- 1 <= coins.length <= 10^5
- 1 <= coins[i] <= target <= 10^9

---

## 📋 面试要点速查（知识卡片）

### 核心思路
**一句话总结**：贪心算法，维护当前能表示的最大连续金额，当无法表示下一个金额时，添加面值为"当前最大+1"的硬币。

**关键词**：`贪心算法` `子序列和` `连续金额覆盖`

### 复杂度速记
- **时间复杂度**：O(n log n) - 排序 + O(n) 遍历 = O(n log n)
- **空间复杂度**：O(1) - 只使用几个变量

### 记忆口诀
"排序后贪心，维护连续范围，缺啥补啥"

---

## 解题思路

### 核心思想

**贪心算法**：
- 维护 `s` 表示当前能用已有硬币表示的最大连续金额（即能表示 `[1, s]` 的所有整数）
- 如果当前硬币 `coins[i] <= s + 1`，说明可以用它扩展连续范围到 `s + coins[i]`
- 否则，需要添加面值为 `s + 1` 的硬币，将范围扩展到 `2s + 1`

### 算法步骤

1. 对 `coins` 数组进行排序
2. 初始化 `s = 0`（当前能表示的最大连续金额），`res = 0`（需要添加的硬币数），`i = 0`（当前遍历的硬币索引）
3. 当 `s < target` 时循环：
   - 如果 `i < n` 且 `coins[i] <= s + 1`：
     - 可以用当前硬币扩展范围：`s += coins[i]`
     - `i += 1`
   - 否则：
     - 需要添加面值为 `s + 1` 的硬币
     - `res += 1`
     - `s += (s + 1)`，即范围扩展到 `2s + 1`
4. 返回 `res`

### 为什么选择这个方法？

- **贪心正确性**：当无法表示 `s + 1` 时，添加 `s + 1` 是最优选择，因为：
  - 添加更小的硬币无法覆盖 `s + 1`
  - 添加更大的硬币会留下 `s + 1` 无法表示
  - 添加 `s + 1` 可以将范围从 `[1, s]` 扩展到 `[1, 2s + 1]`，覆盖范围最大
- **时间复杂度**：O(n log n)，主要是排序
- **空间复杂度**：O(1)，只使用常数空间

---

## 完整代码实现

### 贪心算法（推荐）⭐

```python
class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        coins.sort()
        n = len(coins)
        res = 0
        s, i = 0, 0
        
        while s < target:
            if i < n and coins[i] <= s + 1:
                s += coins[i]
                i += 1
            else:
                res += 1
                s += (s + 1)
        
        return res
```

**复杂度分析：**
- 时间复杂度：O(n log n)，排序 + O(n) 遍历
- 空间复杂度：O(1)，只使用常数空间

---

## 算法图解

### 示例 1：coins = [1,4,10], target = 19

```
排序后: [1, 4, 10]

初始: s = 0, res = 0, i = 0

步骤1: coins[0] = 1 <= s + 1 = 1
       s = 0 + 1 = 1  (能表示 [1, 1])
       i = 1

步骤2: coins[1] = 4 <= s + 1 = 2? 否
       需要添加面值 2
       res = 1
       s = 1 + 2 = 3  (能表示 [1, 3])

步骤3: coins[1] = 4 <= s + 1 = 4
       s = 3 + 4 = 7  (能表示 [1, 7])
       i = 2

步骤4: coins[2] = 10 <= s + 1 = 8? 否
       需要添加面值 8
       res = 2
       s = 7 + 8 = 15  (能表示 [1, 15])

步骤5: coins[2] = 10 <= s + 1 = 16
       s = 15 + 10 = 25  (能表示 [1, 25])
       i = 3

s = 25 >= target = 19，结束

结果: res = 2
```

### 示例 2：coins = [1,4,10,5,7,19], target = 19

```
排序后: [1, 4, 5, 7, 10, 19]

初始: s = 0, res = 0, i = 0

步骤1: coins[0] = 1 <= s + 1 = 1
       s = 1  (能表示 [1, 1])
       i = 1

步骤2: coins[1] = 4 <= s + 1 = 2? 否
       需要添加面值 2
       res = 1
       s = 1 + 2 = 3  (能表示 [1, 3])

步骤3: coins[1] = 4 <= s + 1 = 4
       s = 3 + 4 = 7  (能表示 [1, 7])
       i = 2

步骤4: coins[2] = 5 <= s + 1 = 8
       s = 7 + 5 = 12  (能表示 [1, 12])
       i = 3

步骤5: coins[3] = 7 <= s + 1 = 13
       s = 12 + 7 = 19  (能表示 [1, 19])
       i = 4

s = 19 >= target = 19，结束

结果: res = 1
```

### 示例 3：coins = [1,1,1], target = 20

```
排序后: [1, 1, 1]

初始: s = 0, res = 0, i = 0

步骤1-3: 使用三个1，s = 3  (能表示 [1, 3])
         i = 3

步骤4: coins[3] 不存在，且 s + 1 = 4 无法表示
       需要添加面值 4
       res = 1
       s = 3 + 4 = 7  (能表示 [1, 7])

步骤5: 需要添加面值 8
       res = 2
       s = 7 + 8 = 15  (能表示 [1, 15])

步骤6: 需要添加面值 16
       res = 3
       s = 15 + 16 = 31  (能表示 [1, 31])

s = 31 >= target = 20，结束

结果: res = 3
```

---

## 常见错误

### ❌ 错误1：理解错误
```python
# 错误：以为需要添加的硬币面值必须从1开始
# 实际上可以添加任意面值的硬币
```

### ❌ 错误2：贪心策略错误
```python
# 错误：当无法表示某个金额时，添加该金额的硬币
# 实际上应该添加 s + 1，这样可以最大化覆盖范围
```

### ✅ 正确思路
- 维护当前能表示的最大连续金额 `s`
- 当 `coins[i] <= s + 1` 时，可以用它扩展范围
- 否则，添加 `s + 1` 面值的硬币，将范围扩展到 `2s + 1`

---

## 测试用例

```python
def test_minimumAddedCoins():
    solution = Solution()
    
    # 示例1
    assert solution.minimumAddedCoins([1,4,10], 19) == 2
    
    # 示例2
    assert solution.minimumAddedCoins([1,4,10,5,7,19], 19) == 1
    
    # 示例3
    assert solution.minimumAddedCoins([1,1,1], 20) == 3
    
    # 边界情况：已有所有需要的硬币
    assert solution.minimumAddedCoins([1,2,3,4,5], 5) == 0
    
    # 边界情况：只有一个硬币且为1
    assert solution.minimumAddedCoins([1], 1) == 0
    
    # 边界情况：需要添加多个硬币
    assert solution.minimumAddedCoins([1], 10) == 3  # 需要添加2,4,8
    
    print("所有测试用例通过！")
```

---

## 相似题目

- [330. 按要求补齐数组](https://leetcode.cn/problems/patching-array/) - 类似思路，需要添加数字使能表示所有目标数
- [1798. 你能构造出连续值的最大数目](https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/) - 判断能构造的最大连续值范围
- [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/) - 计算组合数

---

## 总结

这是一道经典的贪心算法题目，核心思想是：

1. ✅ **维护连续范围**：用 `s` 表示当前能表示的最大连续金额 `[1, s]`
2. ✅ **贪心策略**：当无法表示 `s + 1` 时，添加面值为 `s + 1` 的硬币
3. ✅ **正确性**：添加 `s + 1` 可以将范围从 `[1, s]` 扩展到 `[1, 2s + 1]`，覆盖范围最大

**记住核心思想：**
- 排序后贪心遍历
- 维护 `s` 表示当前能表示的最大连续金额
- 当 `coins[i] <= s + 1` 时扩展范围，否则添加 `s + 1` 面值的硬币
