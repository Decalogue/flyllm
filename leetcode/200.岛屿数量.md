# 200. 岛屿数量

## 题目描述

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

### 示例 1

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

### 示例 2

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

### 提示

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

---

## 解题思路

### 核心思想

这是一个经典的**连通性问题**，可以使用以下方法解决：

1. **DFS（深度优先搜索）**：从每个未访问的陆地开始，递归标记所有相连的陆地
2. **BFS（广度优先搜索）**：使用队列遍历所有相连的陆地
3. **并查集（Union-Find）**：将相邻的陆地合并到同一个集合中

### 算法步骤

1. 遍历整个网格
2. 当遇到 `'1'`（未访问的陆地）时：
   - 岛屿数量 +1
   - 使用DFS/BFS标记所有相连的陆地为已访问（或改为 `'0'`）
3. 返回岛屿数量

---

## 方法一：DFS（深度优先搜索）

### 思路

从每个未访问的陆地开始，递归地访问所有相邻的陆地，并将它们标记为已访问。

### 代码实现

```python
from typing import List

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        count = 0
        
        def dfs(i, j):
            # 边界检查和有效性检查
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0':
                return
            
            # 标记为已访问
            grid[i][j] = '0'
            
            # 递归访问四个方向
            dfs(i + 1, j)  # 下
            dfs(i - 1, j)  # 上
            dfs(i, j + 1)  # 右
            dfs(i, j - 1)  # 左
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    count += 1
                    dfs(i, j)
        
        return count
```

### 复杂度分析

- **时间复杂度**：O(m × n)，其中 m 和 n 分别是网格的行数和列数。每个单元格最多被访问一次。
- **空间复杂度**：O(m × n)，最坏情况下整个网格都是陆地，递归栈的深度可能达到 m × n。

---

## 方法二：BFS（广度优先搜索）

### 思路

使用队列实现广度优先搜索，从每个未访问的陆地开始，逐层访问所有相邻的陆地。

### 代码实现

```python
from collections import deque
from typing import List

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        count = 0
        
        # 方向数组：上、下、左、右
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        def bfs(start_i, start_j):
            queue = deque([(start_i, start_j)])
            grid[start_i][start_j] = '0'  # 标记为已访问
            
            while queue:
                i, j = queue.popleft()
                
                # 遍历四个方向
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    
                    # 检查边界和有效性
                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == '1':
                        grid[ni][nj] = '0'  # 标记为已访问
                        queue.append((ni, nj))
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    count += 1
                    bfs(i, j)
        
        return count
```

### 复杂度分析

- **时间复杂度**：O(m × n)，每个单元格最多被访问一次。
- **空间复杂度**：O(min(m, n))，队列的最大长度取决于网格的宽度或高度（取较小值）。

---

## 方法三：并查集（Union-Find）

### 思路

使用并查集数据结构，将相邻的陆地合并到同一个集合中，最后统计集合的数量。

### 代码实现

```python
from typing import List

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
    
    def unite(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        
        if rootX != rootY:
            # 按秩合并
            if self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            elif self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1
            self.count -= 1
    
    def get_count(self):
        return self.count

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        
        # 统计陆地数量
        land_count = sum(1 for row in grid for cell in row if cell == '1')
        
        uf = UnionFind(m * n)
        
        # 方向数组：下、右
        directions = [(1, 0), (0, 1)]
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    id1 = i * n + j
                    
                    # 只检查下和右（避免重复）
                    for di, dj in directions:
                        ni, nj = i + di, j + dj
                        
                        if ni < m and nj < n and grid[ni][nj] == '1':
                            id2 = ni * n + nj
                            uf.unite(id1, id2)
        
        # 岛屿数量 = 总集合数 - 水域数量
        return uf.get_count() - (m * n - land_count)
```

### 复杂度分析

- **时间复杂度**：O(m × n × α(m × n))，其中 α 是阿克曼函数的反函数，在实际应用中可以视为常数。
- **空间复杂度**：O(m × n)，用于存储并查集。

---

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| **DFS** | O(m × n) | O(m × n) | 代码简洁，易于理解 | 递归栈可能很深 |
| **BFS** | O(m × n) | O(min(m, n)) | 空间复杂度更优 | 代码稍复杂 |
| **并查集** | O(m × n × α) | O(m × n) | 适合动态连通性问题 | 代码复杂，常数因子大 |

### 推荐方法

- **面试推荐**：DFS（代码简洁，易于解释）
- **生产环境**：BFS（空间复杂度更优）
- **动态场景**：并查集（支持动态添加/删除）

---

## 测试用例

```python
def test_num_islands():
    solution = Solution()
    
    # 测试用例1
    grid1 = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"]
    ]
    assert solution.numIslands(grid1) == 1
    
    # 测试用例2
    grid2 = [
        ["1","1","0","0","0"],
        ["1","1","0","0","0"],
        ["0","0","1","0","0"],
        ["0","0","0","1","1"]
    ]
    assert solution.numIslands(grid2) == 3
    
    # 测试用例3：单个岛屿
    grid3 = [["1"]]
    assert solution.numIslands(grid3) == 1
    
    # 测试用例4：全是水
    grid4 = [["0","0","0"],["0","0","0"]]
    assert solution.numIslands(grid4) == 0
    
    # 测试用例5：全是陆地
    grid5 = [["1","1"],["1","1"]]
    assert solution.numIslands(grid5) == 1
    
    print("所有测试用例通过！")

test_num_islands()
```

---

## 相关题目

- [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)
- [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)
- [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)
- [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

---

## 总结

这是一道经典的**图遍历问题**，核心是：

1. **识别问题类型**：连通性问题，需要找到所有连通的组件
2. **选择算法**：DFS/BFS/并查集都可以解决
3. **标记访问**：避免重复访问，可以通过修改原数组或使用visited数组
4. **边界检查**：确保不越界

**关键技巧**：
- 使用方向数组简化代码
- 直接在原数组上标记（沉没岛屿），节省空间
- DFS递归时注意栈溢出问题（大网格用BFS）
