# 15. 三数之和

## 题目描述

给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。

请你返回所有和为 `0` 且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。

### 示例 1

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
不同的三元组是 [-1,0,1] 和 [-1,-1,2]。
注意，输出的顺序和三元组的顺序并不重要。
```

### 示例 2

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0。
```

### 示例 3

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0。
```

### 提示

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

---

## 解题思路

### 核心思想

使用**排序 + 双指针**的方法，固定一个数，然后用双指针寻找另外两个数。

**关键点：**
- 先对数组排序，便于去重和双指针操作
- 固定第一个数 `nums[i]`，在剩余部分用双指针寻找 `nums[left] + nums[right] = -nums[i]`
- 通过跳过重复元素来避免重复的三元组
- 利用排序后的特性进行早期剪枝优化

### 算法步骤

1. 对数组进行排序
2. 枚举第一个数 `i`（从 0 到 n-3）
3. 对于每个 `i`：
   - 跳过重复的 `i` 值
   - 设置 `target = -nums[i]`
   - 使用双指针 `left = i + 1` 和 `right = n - 1`
   - 当 `left < right` 时：
     - 如果 `nums[left] + nums[right] == target`，记录答案并移动指针
     - 如果和小于 `target`，`left++`
     - 如果和大于 `target`，`right--`
   - 移动指针时跳过重复元素

---

## 代码实现

### Leetcode 官方解法

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        res = []
        
        # 枚举 a
        for i in range(n):
            # 需要和上一次枚举的数不相同
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            # c 对应的指针初始指向数组的最右端
            k = n - 1
            target = -nums[i]
            # 枚举 b
            for j in range(i + 1, n):
                # 需要和上一次枚举的数不相同
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                # 需要保证 b 的指针在 c 的指针的左侧
                while j < k and nums[j] + nums[k] > target:
                    k -= 1
                # 如果指针重合，随着 b 后续的增加
                # 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if j == k:
                    break
                if nums[j] + nums[k] == target:
                    res.append([nums[i], nums[j], nums[k]])
        
        return res
```

### 同思路更简洁解法

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        res = set()
        for i in range(n):
            target = -nums[i]
            left, right = i + 1, n - 1
            while left < right:
                two_sum = nums[left] + nums[right]
                if target > two_sum:
                    left += 1
                elif target < two_sum:
                    right -= 1
                else:
                    res.add((nums[i], nums[left], nums[right]))
                    left += 1
                    right -= 1
        return list(map(list, res))
```


### 优化后的双指针解法（推荐）

标准的双指针解法已经是**理论最优**（O(n²)），但可以通过以下优化提升实际运行速度：

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        res = []
        
        # 优化1: 只遍历到n-2
        for i in range(n - 2):
            # 优化2: 早期剪枝 - 如果最小的三个数之和都大于0，直接退出
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break
            # 优化3: 如果当前数和最大的两个数之和都小于0，跳过
            if nums[i] + nums[n - 1] + nums[n - 2] < 0:
                continue
            # 去重
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            
            target = -nums[i]
            left, right = i + 1, n - 1
            
            while left < right:
                two_sum = nums[left] + nums[right]
                if two_sum < target:
                    left += 1
                elif two_sum > target:
                    right -= 1
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    # 优化4: 跳过重复元素
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
        
        return res
```

### 执行过程示例

以 `nums = [-1, 0, 1, 2, -1, -4]` 为例：

```
排序后：nums = [-4, -1, -1, 0, 1, 2]

i = 0, nums[0] = -4:
  target = 4
  left = 1, right = 5
  nums[1] + nums[5] = -1 + 2 = 1 < 4, left++
  nums[2] + nums[5] = -1 + 2 = 1 < 4, left++
  nums[3] + nums[5] = 0 + 2 = 2 < 4, left++
  nums[4] + nums[5] = 1 + 2 = 3 < 4, left++
  left >= right, 结束

i = 1, nums[1] = -1:
  target = 1
  left = 2, right = 5
  nums[2] + nums[5] = -1 + 2 = 1 == 1, 找到答案 [-1, -1, 2]
  left++, right--, 跳过重复
  nums[3] + nums[4] = 0 + 1 = 1 == 1, 找到答案 [-1, 0, 1]
  left++, right--, left >= right, 结束

i = 2, nums[2] = -1:
  nums[2] == nums[1], 跳过（去重）

i = 3, nums[3] = 0:
  target = 0
  left = 4, right = 5
  nums[4] + nums[5] = 1 + 2 = 3 > 0, right--
  left >= right, 结束

结果：[[-1, -1, 2], [-1, 0, 1]]
```

---

## 优化点说明

1. **边界优化**：`range(n - 2)` 避免无效遍历
2. **早期剪枝**：
   - 如果 `nums[i] + nums[i+1] + nums[i+2] > 0`，后续所有组合都大于0，直接退出
   - 如果 `nums[i] + nums[n-1] + nums[n-2] < 0`，当前i无法找到解，跳过
3. **去重优化**：在找到答案后，同时跳过左右指针的重复元素

---

## 复杂度分析

- **时间复杂度**：O(n²)
  - 排序：O(n log n)
  - 双指针遍历：O(n²)
  - 总体：O(n²)（n² 主导）
- **空间复杂度**：O(1)（不考虑输出数组和排序的额外空间）

---

## 关键点

1. **为什么需要排序？**
   - 排序后可以使用双指针技巧，将 O(n³) 降低到 O(n²)
   - 排序后便于去重，只需比较相邻元素

2. **去重的时机**
   - **第一个数去重**：`if i > 0 and nums[i] == nums[i - 1]: continue`
   - **找到答案后去重**：同时跳过 `left` 和 `right` 的重复元素
   - 注意：不能在找到答案前就去重，否则会漏掉 `[0, 0, 0]` 这种情况

3. **双指针移动规则**
   - 如果 `nums[left] + nums[right] < target`，需要增大和，`left++`
   - 如果 `nums[left] + nums[right] > target`，需要减小和，`right--`
   - 如果相等，记录答案并同时移动两个指针

4. **为什么这是最优解？**
   - **理论下界**：三数之和问题需要检查所有可能的组合，无法避免O(n²)的时间复杂度
   - **实际性能**：双指针法常数因子小，实际运行速度快
   - **代码简洁**：逻辑清晰，易于理解和维护

---

## 其他方法

### 哈希表解法（不推荐）

虽然可以使用哈希表，但：
- 时间复杂度仍然是O(n²)
- 空间复杂度变为O(n)
- 需要处理重复元素的复杂逻辑
- 实际运行速度通常不如双指针法

### 暴力法（不推荐）

```python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    n = len(nums)
    res = set()
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] + nums[j] + nums[k] == 0:
                    res.add(tuple(sorted([nums[i], nums[j], nums[k]])))
    return [list(t) for t in res]
```

- **时间复杂度**：O(n³)
- **空间复杂度**：O(1)

---

## 相关题目

- [1.两数之和](https://leetcode.cn/problems/two-sum/)
- [16.最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)
- [18.四数之和](https://leetcode.cn/problems/4sum/)
- [167.两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

---

## 总结

这是一道经典的**双指针**题目，核心是：

1. **识别问题类型**：三数之和可以转化为固定一个数，然后找两数之和
2. **排序的重要性**：排序后可以使用双指针技巧，并便于去重
3. **去重技巧**：在固定第一个数和找到答案后都要去重
4. **早期剪枝**：利用排序后的特性进行优化，提升实际运行速度

**关键技巧**：
- ✅ 先排序，再使用双指针
- ✅ 固定第一个数，在剩余部分用双指针找两数之和
- ✅ 注意去重的时机：固定第一个数时去重，找到答案后也要去重
- ✅ 利用排序特性进行早期剪枝优化
- ✅ 双指针移动规则：和小于目标值则左指针右移，和大于目标值则右指针左移